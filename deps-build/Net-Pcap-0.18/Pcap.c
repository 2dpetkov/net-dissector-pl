/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.39 from the
 * contents of Pcap.xs. Do not edit this file, edit Pcap.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Pcap.xs"
/*
 * Pcap.xs
 *
 * XS wrapper for LBL pcap(3) library.
 *
 * Copyright (C) 2005, 2006, 2007, 2008, 2009 Sebastien Aperghis-Tramoni 
 *   with some code contributed by Jean-Louis Morel. All rights reserved.
 * Copyright (C) 2003 Marco Carnut. All rights reserved. 
 * Copyright (C) 1999 Tim Potter. All rights reserved. 
 *
 * This program is free software; you can redistribute it and/or modify it 
 * under the same terms as Perl itself.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _CYGWIN
#include <windows.h>
#endif

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#define NEED_PL_signals 1
#define NEED_sv_2pv_nolen 1
#include "ppport.h"

#include <pcap.h>

#ifdef _CYGWIN
#include <Win32-Extensions.h>
#endif

/* Perl specific constants */
#define PERL_SIGNALS_SAFE       0x00010000
#define PERL_SIGNALS_UNSAFE     0x00010001

#include "const-c.inc"
#include "stubs.inc"

#ifdef __cplusplus
}
#endif


typedef struct bpf_program  pcap_bpf_program_t;

/* A struct for holding the user context and callback information*/
typedef struct User_Callback {
    SV *callback_fn;
    SV *user;
} User_Callback;


/* Wrapper for callback function */

void callback_wrapper(u_char *user, const struct pcap_pkthdr *h, const u_char *pkt) {
    SV *packet  = newSVpvn((char *)pkt, h->caplen);
    HV *hdr     = newHV();
    SV *ref_hdr = newRV_inc((SV*)hdr);
    User_Callback* user_callback = (User_Callback*) user;

    /* Fill the hash fields */
    hv_store(hdr, "tv_sec",  strlen("tv_sec"),  newSViv(h->ts.tv_sec),  0);
    hv_store(hdr, "tv_usec", strlen("tv_usec"), newSViv(h->ts.tv_usec), 0);
    hv_store(hdr, "caplen",  strlen("caplen"),  newSVuv(h->caplen),     0);
    hv_store(hdr, "len",     strlen("len"),     newSVuv(h->len),        0);	

    /* Push arguments onto stack */
    dSP;
    PUSHMARK(sp);
    XPUSHs((SV*)user_callback->user);
    XPUSHs(ref_hdr);
    XPUSHs(packet);
    PUTBACK;

    /* Call perl function */
    call_sv (user_callback->callback_fn, G_DISCARD);

    /* Decrement refcount to temp SVs */
    SvREFCNT_dec(packet);
    SvREFCNT_dec(hdr);
    SvREFCNT_dec(ref_hdr);
}


#line 101 "Pcap.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 245 "Pcap.c"

/* INCLUDE:  Including 'const-xs.inc' from 'Pcap.xs' */


XS_EUPXS(XS_Net__Pcap_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_constant)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 4 "./const-xs.inc"
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	IV		iv = 0; /* avoid uninit var warning */
	/* NV		nv;	Uncomment this if you need to return NVs */
	/* const char	*pv;	Uncomment this if you need to return PVs */
#line 270 "Pcap.c"
	SV *	sv = ST(0)
;
	const char *	s = SvPV(sv, len);
#line 18 "./const-xs.inc"
        /* Change this to constant(aTHX_ s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = constant(aTHX_ s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv =
	    sv_2mortal(newSVpvf("%s is not a valid pcap macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined pcap macro %s, used",
				   s));
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          EXTEND(SP, 2);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break;
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 2);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 2);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
	/* Uncomment this if you need to return PVs
        case PERL_constant_ISPV:
          EXTEND(SP, 2);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break; */
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 2);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 2);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 2);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 2);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing pcap macro %s, used",
               type, s));
          PUSHs(sv);
        }
#line 348 "Pcap.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Pcap.xs' from 'const-xs.inc' */


XS_EUPXS(XS_Net__Pcap_lookupdev); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_lookupdev)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "err");
    {
	SV *	err = ST(0)
;
	char *	RETVAL;
	dXSTARG;
#line 103 "Pcap.xs"
		if (SvROK(err)) {
            char    *errbuf = NULL;
            SV      *err_sv = SvRV(err);

            Newx(errbuf, PCAP_ERRBUF_SIZE+1, char);
			RETVAL = pcap_lookupdev(errbuf);
#ifdef WPCAP
            {   /* Conversion from Windows Unicode (UCS-2) to ANSI */
                int     size    = lstrlenW((PWSTR)RETVAL) + 2;
                char    *str    = NULL;

                Newx(str, size, char); 
                WideCharToMultiByte(CP_ACP, 0, (PWSTR)RETVAL, -1, str, size, NULL, NULL);	
                lstrcpyA(RETVAL, str);
                Safefree(str);
            }
#endif /* WPCAP */
			if (RETVAL == NULL) {
				sv_setpv(err_sv, errbuf);
			} else {
				err_sv = &PL_sv_undef;
			}

			safefree(errbuf);

		} else
			croak("arg1 not a hash ref");

#line 398 "Pcap.c"
	ST(0) = err;
	SvSETMAGIC(ST(0));
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_lookupnet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_lookupnet)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "device, net, mask, err");
    {
	const char *	device = (const char *)SvPV_nolen(ST(0))
;
	SV *	net = ST(1)
;
	SV *	mask = ST(2)
;
	SV *	err = ST(3)
;
	int	RETVAL;
	dXSTARG;
#line 144 "Pcap.xs"
		if (SvROK(net) && SvROK(mask) && SvROK(err)) {
			bpf_u_int32  netp, maskp;
            char    *errbuf     = NULL;
            SV      *net_sv     = SvRV(net);
            SV      *mask_sv    = SvRV(mask);
            SV      *err_sv     = SvRV(err);

            Newx(errbuf, PCAP_ERRBUF_SIZE+1, char);
			RETVAL = pcap_lookupnet(device, &netp, &maskp, errbuf);

			netp = ntohl(netp);
			maskp = ntohl(maskp);

			if (RETVAL != -1) {
				sv_setuv(net_sv, netp);
				sv_setuv(mask_sv, maskp);
				err_sv = &PL_sv_undef;
			} else {
				sv_setpv(err_sv, errbuf);
			}

			safefree(errbuf);

		} else {
			RETVAL = -1;
			if (!SvROK(net )) croak("arg2 not a reference");
			if (!SvROK(mask)) croak("arg3 not a reference");
			if (!SvROK(err )) croak("arg4 not a reference");
		}

#line 455 "Pcap.c"
	ST(1) = net;
	SvSETMAGIC(ST(1));
	ST(2) = mask;
	SvSETMAGIC(ST(2));
	ST(3) = err;
	SvSETMAGIC(ST(3));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_findalldevs_xs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_findalldevs_xs)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "devinfo, err");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	devinfo = ST(0)
;
	SV *	err = ST(1)
;
#line 187 "Pcap.xs"
        char    *errbuf = NULL;
        Newx(errbuf, PCAP_ERRBUF_SIZE+1, char);

#line 485 "Pcap.c"
#line 191 "Pcap.xs"
        if ( SvROK(err) && SvROK(devinfo) && (SvTYPE(SvRV(devinfo)) == SVt_PVHV) ) {
            int r;
            pcap_if_t *alldevs, *d;
            HV *hv;
            SV *err_sv = SvRV(err);

            hv = (HV *)SvRV(devinfo);

            r = pcap_findalldevs(&alldevs, errbuf);

            switch(r) {
                case 0: /* normal case */
                    for (d=alldevs; d; d=d->next) {
                        XPUSHs(sv_2mortal(newSVpv(d->name, 0)));

                        if (d->description)
                            hv_store(hv, d->name, strlen(d->name), newSVpv(d->description, 0), 0);
                        else
                            if ( (strcmp(d->name,"lo") == 0) || (strcmp(d->name,"lo0") == 0)) 
                                hv_store(hv, d->name, strlen(d->name), 
                                        newSVpv("Loopback device", 0), 0);
                            else
                                hv_store(hv, d->name, strlen(d->name), 
                                        newSVpv("No description available", 0), 0);
                    }

                    pcap_freealldevs(alldevs);
                    err_sv = &PL_sv_undef;
                    break;

                case 3: { /* function is not available */
                    char *dev = pcap_lookupdev(errbuf);

                    if (dev == NULL) {
                        sv_setpv(err_sv, errbuf);
                        break;
                    }

                    XPUSHs(sv_2mortal(newSVpv(dev, 0)));
                    if ( (strcmp(dev,"lo") == 0) || (strcmp(dev,"lo0") == 0)) 
                        hv_store(hv, dev, strlen(dev), newSVpv("", 0), 0);
                    else
                        hv_store(hv, dev, strlen(dev), newSVpv("No description available", 0), 0);
                    break;
                }

                case -1: /* error */
                    sv_setpv(err_sv, errbuf); 
                    break;
            }
        } else {
            if ( !SvROK(devinfo) || (SvTYPE(SvRV(devinfo)) != SVt_PVHV) ) 
                croak("arg1 not a hash ref");
            if ( !SvROK(err) )
                croak("arg2 not a scalar ref");
        }
        safefree(errbuf);
#line 544 "Pcap.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Net__Pcap_open_live); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_open_live)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "device, snaplen, promisc, to_ms, err");
    {
	const char *	device = (const char *)SvPV_nolen(ST(0))
;
	int	snaplen = (int)SvIV(ST(1))
;
	int	promisc = (int)SvIV(ST(2))
;
	int	to_ms = (int)SvIV(ST(3))
;
	SV *	err = ST(4)
;
	pcap_t *	RETVAL;
#line 259 "Pcap.xs"
		if (SvROK(err)) {
            char    *errbuf = NULL;
            SV      *err_sv = SvRV(err);

            Newx(errbuf, PCAP_ERRBUF_SIZE+1, char);
#ifdef _MSC_VER
            /* Net::Pcap hangs when to_ms == 0 under ActivePerl/MSVC */
            if (to_ms == 0)
                to_ms = 1;
#endif
			RETVAL = pcap_open_live(device, snaplen, promisc, to_ms, errbuf);

			if (RETVAL == NULL) {
				sv_setpv(err_sv, errbuf);
			} else {
				err_sv = &PL_sv_undef;
			}

			safefree(errbuf);

		} else
			croak("arg5 not a reference");

#line 593 "Pcap.c"
	ST(4) = err;
	SvSETMAGIC(ST(4));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "pcap_tPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_open_dead); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_open_dead)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "linktype, snaplen");
    {
	int	linktype = (int)SvIV(ST(0))
;
	int	snaplen = (int)SvIV(ST(1))
;
	pcap_t *	RETVAL;

	RETVAL = pcap_open_dead(linktype, snaplen);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "pcap_tPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_open_offline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_open_offline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fname, err");
    {
	const char *	fname = (const char *)SvPV_nolen(ST(0))
;
	SV *	err = ST(1)
;
	pcap_t *	RETVAL;
#line 302 "Pcap.xs"
		if (SvROK(err)) {
            char    *errbuf = NULL;
            SV      *err_sv = SvRV(err);

            Newx(errbuf, PCAP_ERRBUF_SIZE+1, char);
			RETVAL = pcap_open_offline(fname, errbuf);

			if (RETVAL == NULL) {
				sv_setpv(err_sv, errbuf);
			} else {
				err_sv = &PL_sv_undef;
			}

			safefree(errbuf);

		} else
			croak("arg2 not a reference");	

#line 663 "Pcap.c"
	ST(1) = err;
	SvSETMAGIC(ST(1));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "pcap_tPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_dump_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_dump_open)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, fname");
    {
	pcap_t *	p;
	const char *	fname = (const char *)SvPV_nolen(ST(1))
;
	pcap_dumper_t *	RETVAL;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_dump_open(p, fname);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "pcap_dumper_tPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_setnonblock); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_setnonblock)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "p, nb, err");
    {
	pcap_t *	p;
	int	nb = (int)SvIV(ST(1))
;
	SV *	err = ST(2)
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;
#line 338 "Pcap.xs"
		if (SvROK(err)) {
            char    *errbuf = NULL;
            SV      *err_sv = SvRV(err);

            Newx(errbuf, PCAP_ERRBUF_SIZE+1, char);
			RETVAL = pcap_setnonblock(p, nb, errbuf);

			if (RETVAL == -1) {
				sv_setpv(err_sv, errbuf);
			} else {
				err_sv = &PL_sv_undef;
			}

			safefree(errbuf);

		} else
			croak("arg3 not a reference");	

#line 750 "Pcap.c"
	ST(2) = err;
	SvSETMAGIC(ST(2));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_getnonblock); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_getnonblock)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, err");
    {
	pcap_t *	p;
	SV *	err = ST(1)
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;
#line 367 "Pcap.xs"
        if (SvROK(err)) {
            char    *errbuf = NULL;
            SV      *err_sv = SvRV(err);

            Newx(errbuf, PCAP_ERRBUF_SIZE+1, char);
            RETVAL = pcap_getnonblock(p, errbuf);

            if (RETVAL == -1) {
                sv_setpv(err_sv, errbuf);
            } else {
                err_sv = &PL_sv_undef;
            }

            safefree(errbuf);

		} else
			croak("arg2 not a reference");	

#line 798 "Pcap.c"
	ST(1) = err;
	SvSETMAGIC(ST(1));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_dispatch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_dispatch)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "p, cnt, callback, user");
    {
	pcap_t *	p;
	int	cnt = (int)SvIV(ST(1))
;
	SV *	callback = ST(2)
;
	SV *	user = ST(3)
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;
#line 398 "Pcap.xs"
    User_Callback user_callback;
    {
		user_callback.callback_fn = newSVsv(callback);
		user_callback.user = newSVsv(user);

		*(pcap_geterr(p)) = '\0';   /* reset error string */

		RETVAL = pcap_dispatch(p, cnt, callback_wrapper, (u_char *)&user_callback);

		SvREFCNT_dec(user_callback.user);
		SvREFCNT_dec(user_callback.callback_fn);
    }	
#line 844 "Pcap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_loop); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_loop)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "p, cnt, callback, user");
    {
	pcap_t *	p;
	int	cnt = (int)SvIV(ST(1))
;
	SV *	callback = ST(2)
;
	SV *	user = ST(3)
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;
#line 422 "Pcap.xs"
    User_Callback user_callback;
    {
		user_callback.callback_fn = newSVsv(callback);
		user_callback.user = newSVsv(user);

		RETVAL = pcap_loop(p, cnt, callback_wrapper, (u_char *)&user_callback);

		SvREFCNT_dec(user_callback.user);
		SvREFCNT_dec(user_callback.callback_fn);
    }
#line 886 "Pcap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_next)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, pkt_header");
    {
	pcap_t *	p;
	SV *	pkt_header = ST(1)
;
	SV *	RETVAL;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;
#line 442 "Pcap.xs"
		if (SvROK(pkt_header) && (SvTYPE(SvRV(pkt_header)) == SVt_PVHV)) {
			struct pcap_pkthdr real_h;
			const u_char *result;
			HV *hv;

			memset(&real_h, '\0', sizeof(real_h));

			result = pcap_next(p, &real_h);

			hv = (HV *)SvRV(pkt_header);	

			if (result != NULL) {
				hv_store(hv, "tv_sec",  strlen("tv_sec"),  newSViv(real_h.ts.tv_sec),  0);
				hv_store(hv, "tv_usec", strlen("tv_usec"), newSViv(real_h.ts.tv_usec), 0);
				hv_store(hv, "caplen",  strlen("caplen"),  newSVuv(real_h.caplen),     0);
				hv_store(hv, "len",     strlen("len"),     newSVuv(real_h.len),        0);	

				RETVAL = newSVpv((char *)result, real_h.caplen);

			} else 
				RETVAL = &PL_sv_undef;

		} else
            croak("arg2 not a hash ref");	

#line 938 "Pcap.c"
	ST(1) = pkt_header;
	SvSETMAGIC(ST(1));
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_next_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_next_ex)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "p, pkt_header, pkt_data");
    {
	pcap_t *	p;
	SV *	pkt_header = ST(1)
;
	SV *	pkt_data = ST(2)
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;
#line 479 "Pcap.xs"
        /* Check if pkt_header is a hashref and pkt_data a scalarref */
        if (SvROK(pkt_header) && (SvTYPE(SvRV(pkt_header)) == SVt_PVHV) && SvROK(pkt_data)) {
			struct pcap_pkthdr *header;
			const u_char *data;
			HV *hv;

			memset(&header, '\0', sizeof(header));

			RETVAL = pcap_next_ex(p, &header, &data);

			hv = (HV *)SvRV(pkt_header);	

			if (RETVAL == 1) {
                hv_store(hv, "tv_sec",  strlen("tv_sec"),  newSViv(header->ts.tv_sec),  0);
                hv_store(hv, "tv_usec", strlen("tv_usec"), newSViv(header->ts.tv_usec), 0);
                hv_store(hv, "caplen",  strlen("caplen"),  newSVuv(header->caplen),     0);
                hv_store(hv, "len",     strlen("len"),     newSVuv(header->len),        0);	

                sv_setpvn((SV *)SvRV(pkt_data), (char *) data, header->caplen);
            }

        } else {
            RETVAL = -1;
            if (!SvROK(pkt_header) || (SvTYPE(SvRV(pkt_header)) != SVt_PVHV))
                croak("arg2 not a hash ref");
            if (!SvROK(pkt_data))
                croak("arg3 not a scalar ref");
        }

#line 1000 "Pcap.c"
	ST(1) = pkt_header;
	SvSETMAGIC(ST(1));
	ST(2) = pkt_data;
	SvSETMAGIC(ST(2));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_dump); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_dump)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "p, pkt_header, sp");
    {
	pcap_dumper_t *	p;
	SV *	pkt_header = ST(1)
;
	SV *	sp = ST(2)
;

        if (sv_derived_from(ST(0), "pcap_dumper_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_dumper_t *) tmp;
        }
        else
            croak("p is not of type pcap_dumper_tPtr")
;
#line 521 "Pcap.xs"
		/* Check if pkt_header is a hashref */
		if (SvROK(pkt_header) && (SvTYPE(SvRV(pkt_header)) == SVt_PVHV)) {
		        struct pcap_pkthdr real_h;
			char *real_sp;
			HV *hv;
			SV **sv;

			memset(&real_h, '\0', sizeof(real_h));

			/* Copy from hash to pcap_pkthdr */
			hv = (HV *)SvRV(pkt_header);

			sv = hv_fetch(hv, "tv_sec", strlen("tv_sec"), 0);
			if (sv != NULL) {
				real_h.ts.tv_sec = SvIV(*sv);
			}

			sv = hv_fetch(hv, "tv_usec", strlen("tv_usec"), 0);
			if (sv != NULL) {
				real_h.ts.tv_usec = SvIV(*sv);
			}

			sv = hv_fetch(hv, "caplen", strlen("caplen"), 0);
			if (sv != NULL) {
			        real_h.caplen = SvIV(*sv);
		        }

			sv = hv_fetch(hv, "len", strlen("len"), 0);
			if (sv != NULL) {
			        real_h.len = SvIV(*sv);
			}

			real_sp = SvPV(sp, PL_na);

			/* Call pcap_dump() */
			pcap_dump((u_char *)p, &real_h, (u_char *)real_sp);

		} else
            croak("arg2 not a hash ref");
#line 1071 "Pcap.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Net__Pcap_compile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_compile)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "p, fp, str, optimize, mask");
    {
	pcap_t *	p;
	SV *	fp = ST(1)
;
	char *	str = (char *)SvPV_nolen(ST(2))
;
	int	optimize = (int)SvIV(ST(3))
;
	bpf_u_int32	mask = (bpf_u_int32)SvUV(ST(4))
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;
#line 571 "Pcap.xs"
		if (SvROK(fp)) {
            pcap_bpf_program_t  *real_fp = NULL;

            Newx(real_fp, 1, pcap_bpf_program_t);
			*(pcap_geterr(p)) = '\0';   /* reset error string */
			RETVAL = pcap_compile(p, real_fp, str, optimize, mask);
			sv_setref_pv(SvRV(fp), "pcap_bpf_program_tPtr", (void *)real_fp);

		} else
			croak("arg2 not a reference");

#line 1115 "Pcap.c"
	ST(1) = fp;
	SvSETMAGIC(ST(1));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_compile_nopcap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_compile_nopcap)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "snaplen, linktype, fp, str, optimize, mask");
    {
	int	snaplen = (int)SvIV(ST(0))
;
	int	linktype = (int)SvIV(ST(1))
;
	SV *	fp = ST(2)
;
	char *	str = (char *)SvPV_nolen(ST(3))
;
	int	optimize = (int)SvIV(ST(4))
;
	bpf_u_int32	mask = (bpf_u_int32)SvUV(ST(5))
;
	int	RETVAL;
	dXSTARG;
#line 597 "Pcap.xs"
		if (SvROK(fp)) {
            pcap_bpf_program_t  *real_fp = NULL;

            Newx(real_fp, 1, pcap_bpf_program_t);
			RETVAL = pcap_compile_nopcap(snaplen, linktype, real_fp, str, optimize, mask);
			sv_setref_pv(SvRV(fp), "pcap_bpf_program_tPtr", (void *)real_fp);

		} else
			croak("arg3 not a reference");

#line 1156 "Pcap.c"
	ST(2) = fp;
	SvSETMAGIC(ST(2));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_offline_filter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_offline_filter)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "fp, header, p");
    {
	pcap_bpf_program_t *	fp;
	SV *	header = ST(1)
;
	SV *	p = ST(2)
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_bpf_program_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            fp = (pcap_bpf_program_t *) tmp;
        }
        else
            croak("fp is not of type pcap_bpf_program_tPtr")
;
#line 619 "Pcap.xs"
        /* Check that header is a hashref */
        if (SvROK(header) && (SvTYPE(SvRV(header)) == SVt_PVHV)) {
            struct pcap_pkthdr real_h;
            char *real_p;
            HV *hv;
            SV **sv;

            memset(&real_h, '\0', sizeof(real_h));

            /* Copy from hash to pcap_pkthdr */
            hv = (HV *)SvRV(header);

            sv = hv_fetch(hv, "tv_sec", strlen("tv_sec"), 0);
            if (sv != NULL) {
                real_h.ts.tv_sec = SvIV(*sv);
            }

            sv = hv_fetch(hv, "tv_usec", strlen("tv_usec"), 0);
            if (sv != NULL) {
                real_h.ts.tv_usec = SvIV(*sv);
            }

            sv = hv_fetch(hv, "caplen", strlen("caplen"), 0);
            if (sv != NULL) {
                real_h.caplen = SvIV(*sv);
            }

            sv = hv_fetch(hv, "len", strlen("len"), 0);
            if (sv != NULL) {
                real_h.len = SvIV(*sv);
            }

            real_p = SvPV(p, PL_na);

            RETVAL = pcap_offline_filter(fp, &real_h, (unsigned char *) real_p);

        } else
            croak("arg2 not a hash ref");

#line 1227 "Pcap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_setfilter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_setfilter)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, fp");
    {
	pcap_t *	p;
	pcap_bpf_program_t *	fp;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

        if (sv_derived_from(ST(1), "pcap_bpf_program_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            fp = (pcap_bpf_program_t *) tmp;
        }
        else
            croak("fp is not of type pcap_bpf_program_tPtr")
;

	RETVAL = pcap_setfilter(p, fp);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_freecode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_freecode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fp");
    {
	pcap_bpf_program_t *	fp;

        if (sv_derived_from(ST(0), "pcap_bpf_program_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            fp = (pcap_bpf_program_t *) tmp;
        }
        else
            croak("fp is not of type pcap_bpf_program_tPtr")
;

	pcap_freecode(fp);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Net__Pcap_breakloop); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_breakloop)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	pcap_breakloop(p);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Net__Pcap_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	pcap_close(p);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Net__Pcap_dump_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_dump_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_dumper_t *	p;

        if (sv_derived_from(ST(0), "pcap_dumper_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_dumper_t *) tmp;
        }
        else
            croak("p is not of type pcap_dumper_tPtr")
;

	pcap_dump_close(p);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Net__Pcap_dump_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_dump_file)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_dumper_t *	p;
	FILE *	RETVAL;

        if (sv_derived_from(ST(0), "pcap_dumper_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_dumper_t *) tmp;
        }
        else
            croak("p is not of type pcap_dumper_tPtr")
;

	RETVAL = pcap_dump_file(p);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    {
		GV *gv = (GV *)sv_newmortal();
		PerlIO *fp = PerlIO_importFILE(RETVAL,0);
		gv_init_pvn(gv, gv_stashpvs("Net::Pcap",1),"__ANONIO__",10,0);
		if ( fp && do_open(gv, "+<&", 3, FALSE, 0, 0, fp) ) {
		    SV *rv = newRV_inc((SV*)gv);
		    rv = sv_bless(rv, GvSTASH(gv));
		    RETVALSV = sv_2mortal(rv);
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_dump_flush); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_dump_flush)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_dumper_t *	p;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_dumper_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_dumper_t *) tmp;
        }
        else
            croak("p is not of type pcap_dumper_tPtr")
;

	RETVAL = pcap_dump_flush(p);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_datalink); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_datalink)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_datalink(p);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_set_datalink); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_set_datalink)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, linktype");
    {
	pcap_t *	p;
	int	linktype = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_set_datalink(p, linktype);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_datalink_name_to_val); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_datalink_name_to_val)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = pcap_datalink_name_to_val(name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_datalink_val_to_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_datalink_val_to_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "linktype");
    {
	int	linktype = (int)SvIV(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = pcap_datalink_val_to_name(linktype);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_datalink_val_to_description); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_datalink_val_to_description)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "linktype");
    {
	int	linktype = (int)SvIV(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = pcap_datalink_val_to_description(linktype);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_snapshot); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_snapshot)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_snapshot(p);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_is_swapped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_is_swapped)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_is_swapped(p);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_major_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_major_version)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_major_version(p);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_minor_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_minor_version)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_minor_version(p);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_perror); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_perror)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, prefix");
    {
	pcap_t *	p;
	char *	prefix = (char *)SvPV_nolen(ST(1))
;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	pcap_perror(p, prefix);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Net__Pcap_geterr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_geterr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;
	char *	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_geterr(p);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_strerror); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_strerror)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "error");
    {
	int	error = (int)SvIV(ST(0))
;
	char *	RETVAL;
	dXSTARG;

	RETVAL = pcap_strerror(error);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_lib_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_lib_version)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	const char *	RETVAL;
	dXSTARG;

	RETVAL = pcap_lib_version();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_perl_settings); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_perl_settings)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "setting");
    {
	int	setting = (int)SvIV(ST(0))
;
	SV *	RETVAL;
#line 769 "Pcap.xs"
        RETVAL = 0;

        switch (setting) {
            case PERL_SIGNALS_SAFE:
                RETVAL = newSVuv(PL_signals);
                PL_signals = 0;
                break;
            case PERL_SIGNALS_UNSAFE:
                RETVAL = newSVuv(PL_signals);
                PL_signals = PERL_SIGNALS_UNSAFE_FLAG;
                break;
        }

#line 1752 "Pcap.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_file)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;
	FILE *	RETVAL;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_file(p);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    {
		GV *gv = (GV *)sv_newmortal();
		PerlIO *fp = PerlIO_importFILE(RETVAL,0);
		gv_init_pvn(gv, gv_stashpvs("Net::Pcap",1),"__ANONIO__",10,0);
		if ( fp && do_open(gv, "+<&", 3, FALSE, 0, 0, fp) ) {
		    SV *rv = newRV_inc((SV*)gv);
		    rv = sv_bless(rv, GvSTASH(gv));
		    RETVALSV = sv_2mortal(rv);
		}
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_fileno); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_fileno)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_fileno(p);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_get_selectable_fd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_get_selectable_fd)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	pcap_t *	p;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_get_selectable_fd(p);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_stats)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, ps");
    {
	pcap_t *	p;
	SV *	ps = ST(1)
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;
#line 807 "Pcap.xs"
		/* Call pcap_stats() function */

		if (SvROK(ps) && (SvTYPE(SvRV(ps)) == SVt_PVHV)) {
			struct pcap_stat real_ps;
			HV *hv;

			*(pcap_geterr(p)) = '\0';   /* reset error string */

			RETVAL = pcap_stats(p, &real_ps);

			/* Copy pcap_stats fields into hash */

			hv = (HV *)SvRV(ps);

			hv_store(hv, "ps_recv", strlen("ps_recv"), 
						newSVuv(real_ps.ps_recv), 0);
			hv_store(hv, "ps_drop", strlen("ps_drop"), 
						newSVuv(real_ps.ps_drop), 0);
			hv_store(hv, "ps_ifdrop", strlen("ps_ifdrop"), 
						newSVuv(real_ps.ps_ifdrop), 0);

		} else
            croak("arg2 not a hash ref");

#line 1896 "Pcap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_createsrcstr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_createsrcstr)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "source, type, host, port, name, err");
    {
	SV *	source = ST(0)
;
	int	type = (int)SvIV(ST(1))
;
	char *	host = (char *)SvPV_nolen(ST(2))
;
	char *	port = (char *)SvPV_nolen(ST(3))
;
	char *	name = (char *)SvPV_nolen(ST(4))
;
	SV *	err = ST(5)
;
	int	RETVAL;
	dXSTARG;
#line 845 "Pcap.xs"
        if (SvROK(source) && SvROK(err)) {
            char    *errbuf     = NULL;
            char    *sourcebuf  = NULL;
            SV      *err_sv     = SvRV(err);
            SV      *source_sv  = SvRV(source);

            Newx(errbuf, PCAP_ERRBUF_SIZE+1, char);
            Newx(sourcebuf, PCAP_BUF_SIZE+1, char);

            RETVAL = pcap_createsrcstr(sourcebuf, type, host, port, name, errbuf);

            if (RETVAL != -1) {
                sv_setpv(source_sv, sourcebuf);
                err_sv = &PL_sv_undef;
            } else {
                sv_setpv(err_sv, errbuf);
            }

            safefree(errbuf);
            safefree(sourcebuf);

        } else {
            RETVAL = -1;
            if (!SvROK(source)) croak("arg1 not a reference");
            if (!SvROK(err)) croak("arg6 not a reference");
        }

#line 1952 "Pcap.c"
	ST(0) = source;
	SvSETMAGIC(ST(0));
	ST(5) = err;
	SvSETMAGIC(ST(5));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_parsesrcstr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_parsesrcstr)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "source, type, host, port, name, err");
    {
	char *	source = (char *)SvPV_nolen(ST(0))
;
	SV *	type = ST(1)
;
	SV *	host = ST(2)
;
	SV *	port = ST(3)
;
	SV *	name = ST(4)
;
	SV *	err = ST(5)
;
	int	RETVAL;
	dXSTARG;
#line 888 "Pcap.xs"
        if ( !SvROK(type) ) croak("arg2 not a reference");   
        if ( !SvROK(host) ) croak("arg3 not a reference");  
        if ( !SvROK(port) ) croak("arg4 not a reference");
        if ( !SvROK(name) ) croak("arg5 not a reference");
        if ( !SvROK(err ) ) croak("arg6 not a reference");

        else {  
            int     rtype;
            char    *hostbuf    = NULL;
            char    *portbuf    = NULL;
            char    *namebuf    = NULL;
            char    *errbuf     = NULL;
            SV      *type_sv    = SvRV(type);
            SV      *host_sv    = SvRV(host);
            SV      *port_sv    = SvRV(port);
            SV      *name_sv    = SvRV(name);    
            SV      *err_sv     = SvRV(err);    

            Newx(hostbuf, PCAP_BUF_SIZE+1, char);
            Newx(portbuf, PCAP_BUF_SIZE+1, char);
            Newx(namebuf, PCAP_BUF_SIZE+1, char);
            Newx(errbuf, PCAP_ERRBUF_SIZE+1, char);

            RETVAL = pcap_parsesrcstr(source, &rtype, hostbuf, portbuf, namebuf, errbuf);

            if (RETVAL != -1) {
                sv_setiv(type_sv, rtype);
                sv_setpv(host_sv, hostbuf);
                sv_setpv(port_sv, portbuf);
                sv_setpv(name_sv, namebuf);				
                err_sv = &PL_sv_undef;
            } else {
                sv_setpv(err_sv, errbuf);
            }

            safefree(hostbuf);
            safefree(portbuf);
            safefree(namebuf);
            safefree(errbuf);
        }

#line 2026 "Pcap.c"
	ST(1) = type;
	SvSETMAGIC(ST(1));
	ST(2) = host;
	SvSETMAGIC(ST(2));
	ST(3) = port;
	SvSETMAGIC(ST(3));
	ST(4) = name;
	SvSETMAGIC(ST(4));
	ST(5) = err;
	SvSETMAGIC(ST(5));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_open)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "source, snaplen, flags, read_timeout, auth, err");
    {
	char *	source = (char *)SvPV_nolen(ST(0))
;
	int	snaplen = (int)SvIV(ST(1))
;
	int	flags = (int)SvIV(ST(2))
;
	int	read_timeout = (int)SvIV(ST(3))
;
	SV *	auth = ST(4)
;
	SV *	err = ST(5)
;
	pcap_t *	RETVAL;
#line 948 "Pcap.xs"
        if (!SvROK(err))
            croak("arg6 not a reference");

        if ( !SvOK(auth) || (SvOK(auth) && SvROK(auth) && (SvTYPE(SvRV(auth)) == SVt_PVHV)) ) {
            struct pcap_rmtauth real_auth;
            struct pcap_rmtauth *preal_auth;
            char    *errbuf = NULL;
            SV      *err_sv = SvRV(err);

            Newx(errbuf, PCAP_ERRBUF_SIZE+1, char);

            if (!SvOK(auth)) {      /* if auth (struct pcap_rmtauth) is undef */
                preal_auth = NULL;

            } else {                    /* auth (struct pcap_rmtauth) is a hashref */  
                HV *hv;
                SV **sv;

                memset(&real_auth, '\0', sizeof(real_auth));

                /* Copy from hash to pcap_rmtauth */
                hv = (HV *)SvRV(auth);
                sv = hv_fetch(hv, "type", strlen("type"), 0);

                if (sv != NULL)
                    real_auth.type = SvIV(*sv);

                sv = hv_fetch(hv, "username", strlen("username"), 0);

                if (sv != NULL)
                    real_auth.username = SvPV(*sv, PL_na);

                sv = hv_fetch(hv, "password", strlen("password"), 0);

                if (sv != NULL)
                    real_auth.password = SvPV(*sv, PL_na);

                preal_auth = &real_auth;
            }

            RETVAL = pcap_open(source, snaplen, flags, read_timeout, preal_auth, errbuf); 

            if (RETVAL == NULL) {
                sv_setpv(err_sv, errbuf);				
            } else {
                err_sv = &PL_sv_undef;
            }  	  

            safefree(errbuf);

        } else
            croak("arg5 not a hash ref");

#line 2117 "Pcap.c"
	ST(5) = err;
	SvSETMAGIC(ST(5));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "pcap_tPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_setuserbuffer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_setuserbuffer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, size");
    {
	pcap_t *	p;
	int	size = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_setuserbuffer(p, size);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_setbuff); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_setbuff)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, dim");
    {
	pcap_t *	p;
	int	dim = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_setbuff(p, dim);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_setmode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_setmode)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, mode");
    {
	pcap_t *	p;
	int	mode = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_setmode(p, mode);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_setmintocopy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_setmintocopy)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, size");
    {
	pcap_t *	p;
	int	size = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

	RETVAL = pcap_setmintocopy(p, size);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_getevent); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_getevent)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "p");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	pcap_t *	p;
#line 1035 "Pcap.xs"
        unsigned int h;

#line 2256 "Pcap.c"

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;
#line 1038 "Pcap.xs"
        h = (unsigned int) pcap_getevent(p);  
        ST(0) = sv_newmortal();
        sv_setref_iv(ST(0), "Win32::Event", h);
        XSRETURN(1);
#line 2270 "Pcap.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Net__Pcap_sendpacket); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_sendpacket)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "p, buf");
    {
	pcap_t *	p;
	SV *	buf = ST(1)
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;
#line 1050 "Pcap.xs"
        RETVAL = pcap_sendpacket(p, (u_char *)SvPVX(buf), sv_len(buf));  

#line 2300 "Pcap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_sendqueue_alloc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_sendqueue_alloc)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "memsize");
    {
	u_int	memsize = (u_int)SvUV(ST(0))
;
	pcap_send_queue *	RETVAL;

	RETVAL = pcap_sendqueue_alloc(memsize);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "pcap_send_queuePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_pcap_send_queuePtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_pcap_send_queuePtr_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "queue");
    {
	pcap_send_queue *	queue;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    queue = INT2PTR(pcap_send_queue *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"pcap_send_queuePtr::DESTROY",
			"queue")
;
#line 1068 "Pcap.xs"
        pcap_sendqueue_destroy(queue);
#line 2350 "Pcap.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Net__Pcap_sendqueue_queue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_sendqueue_queue)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "queue, header, p");
    {
	pcap_send_queue *	queue;
	SV *	header = ST(1)
;
	SV *	p = ST(2)
;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_send_queuePtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            queue = (pcap_send_queue *) tmp;
        }
        else
            croak("queue is not of type pcap_send_queuePtr")
;
#line 1080 "Pcap.xs"
        /* Check that header is a hashref */
        if (SvROK(header) && (SvTYPE(SvRV(header)) == SVt_PVHV)) {
            struct pcap_pkthdr real_h;
            char *real_p;
            HV *hv;
            SV **sv;

            memset(&real_h, '\0', sizeof(real_h));

            /* Copy from hash to pcap_pkthdr */
            hv = (HV *)SvRV(header);

            sv = hv_fetch(hv, "tv_sec", strlen("tv_sec"), 0);
            if (sv != NULL) {
                real_h.ts.tv_sec = SvIV(*sv);
            }

            sv = hv_fetch(hv, "tv_usec", strlen("tv_usec"), 0);
            if (sv != NULL) {
                real_h.ts.tv_usec = SvIV(*sv);
            }

            sv = hv_fetch(hv, "caplen", strlen("caplen"), 0);
            if (sv != NULL) {
                real_h.caplen = SvIV(*sv);
            }

            sv = hv_fetch(hv, "len", strlen("len"), 0);
            if (sv != NULL) {
                real_h.len = SvIV(*sv);
            }

            real_p = SvPV(p, PL_na);

            /* Call pcap_sendqueue_queue() */
            RETVAL = pcap_sendqueue_queue(queue, &real_h, (unsigned char *) real_p);

        } else
            croak("arg2 not a hash ref");

#line 2419 "Pcap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Net__Pcap_sendqueue_transmit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Net__Pcap_sendqueue_transmit)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "p, queue, sync");
    {
	pcap_t *	p;
	pcap_send_queue *	queue;
	int	sync = (int)SvIV(ST(2))
;
	u_int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "pcap_tPtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            p = (pcap_t *) tmp;
        }
        else
            croak("p is not of type pcap_tPtr")
;

        if (sv_derived_from(ST(1), "pcap_send_queuePtr")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            queue = (pcap_send_queue *) tmp;
        }
        else
            croak("queue is not of type pcap_send_queuePtr")
;

	RETVAL = pcap_sendqueue_transmit(p, queue, sync);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Net__Pcap); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Net__Pcap)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Net::Pcap::constant", XS_Net__Pcap_constant);
        newXS_deffile("Net::Pcap::lookupdev", XS_Net__Pcap_lookupdev);
        newXS_deffile("Net::Pcap::lookupnet", XS_Net__Pcap_lookupnet);
        newXS_deffile("Net::Pcap::findalldevs_xs", XS_Net__Pcap_findalldevs_xs);
        newXS_deffile("Net::Pcap::open_live", XS_Net__Pcap_open_live);
        newXS_deffile("Net::Pcap::open_dead", XS_Net__Pcap_open_dead);
        newXS_deffile("Net::Pcap::open_offline", XS_Net__Pcap_open_offline);
        newXS_deffile("Net::Pcap::dump_open", XS_Net__Pcap_dump_open);
        newXS_deffile("Net::Pcap::setnonblock", XS_Net__Pcap_setnonblock);
        newXS_deffile("Net::Pcap::getnonblock", XS_Net__Pcap_getnonblock);
        newXS_deffile("Net::Pcap::dispatch", XS_Net__Pcap_dispatch);
        newXS_deffile("Net::Pcap::loop", XS_Net__Pcap_loop);
        newXS_deffile("Net::Pcap::next", XS_Net__Pcap_next);
        newXS_deffile("Net::Pcap::next_ex", XS_Net__Pcap_next_ex);
        newXS_deffile("Net::Pcap::dump", XS_Net__Pcap_dump);
        newXS_deffile("Net::Pcap::compile", XS_Net__Pcap_compile);
        newXS_deffile("Net::Pcap::compile_nopcap", XS_Net__Pcap_compile_nopcap);
        newXS_deffile("Net::Pcap::offline_filter", XS_Net__Pcap_offline_filter);
        newXS_deffile("Net::Pcap::setfilter", XS_Net__Pcap_setfilter);
        newXS_deffile("Net::Pcap::freecode", XS_Net__Pcap_freecode);
        newXS_deffile("Net::Pcap::breakloop", XS_Net__Pcap_breakloop);
        newXS_deffile("Net::Pcap::close", XS_Net__Pcap_close);
        newXS_deffile("Net::Pcap::dump_close", XS_Net__Pcap_dump_close);
        newXS_deffile("Net::Pcap::dump_file", XS_Net__Pcap_dump_file);
        newXS_deffile("Net::Pcap::dump_flush", XS_Net__Pcap_dump_flush);
        newXS_deffile("Net::Pcap::datalink", XS_Net__Pcap_datalink);
        newXS_deffile("Net::Pcap::set_datalink", XS_Net__Pcap_set_datalink);
        newXS_deffile("Net::Pcap::datalink_name_to_val", XS_Net__Pcap_datalink_name_to_val);
        newXS_deffile("Net::Pcap::datalink_val_to_name", XS_Net__Pcap_datalink_val_to_name);
        newXS_deffile("Net::Pcap::datalink_val_to_description", XS_Net__Pcap_datalink_val_to_description);
        newXS_deffile("Net::Pcap::snapshot", XS_Net__Pcap_snapshot);
        newXS_deffile("Net::Pcap::is_swapped", XS_Net__Pcap_is_swapped);
        newXS_deffile("Net::Pcap::major_version", XS_Net__Pcap_major_version);
        newXS_deffile("Net::Pcap::minor_version", XS_Net__Pcap_minor_version);
        newXS_deffile("Net::Pcap::perror", XS_Net__Pcap_perror);
        newXS_deffile("Net::Pcap::geterr", XS_Net__Pcap_geterr);
        newXS_deffile("Net::Pcap::strerror", XS_Net__Pcap_strerror);
        newXS_deffile("Net::Pcap::lib_version", XS_Net__Pcap_lib_version);
        newXS_deffile("Net::Pcap::perl_settings", XS_Net__Pcap_perl_settings);
        newXS_deffile("Net::Pcap::file", XS_Net__Pcap_file);
        newXS_deffile("Net::Pcap::fileno", XS_Net__Pcap_fileno);
        newXS_deffile("Net::Pcap::get_selectable_fd", XS_Net__Pcap_get_selectable_fd);
        newXS_deffile("Net::Pcap::stats", XS_Net__Pcap_stats);
        newXS_deffile("Net::Pcap::createsrcstr", XS_Net__Pcap_createsrcstr);
        newXS_deffile("Net::Pcap::parsesrcstr", XS_Net__Pcap_parsesrcstr);
        newXS_deffile("Net::Pcap::open", XS_Net__Pcap_open);
        newXS_deffile("Net::Pcap::setuserbuffer", XS_Net__Pcap_setuserbuffer);
        newXS_deffile("Net::Pcap::setbuff", XS_Net__Pcap_setbuff);
        newXS_deffile("Net::Pcap::setmode", XS_Net__Pcap_setmode);
        newXS_deffile("Net::Pcap::setmintocopy", XS_Net__Pcap_setmintocopy);
        newXS_deffile("Net::Pcap::getevent", XS_Net__Pcap_getevent);
        newXS_deffile("Net::Pcap::sendpacket", XS_Net__Pcap_sendpacket);
        newXS_deffile("Net::Pcap::sendqueue_alloc", XS_Net__Pcap_sendqueue_alloc);
        newXS_deffile("pcap_send_queuePtr::DESTROY", XS_pcap_send_queuePtr_DESTROY);
        newXS_deffile("Net::Pcap::sendqueue_queue", XS_Net__Pcap_sendqueue_queue);
        newXS_deffile("Net::Pcap::sendqueue_transmit", XS_Net__Pcap_sendqueue_transmit);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

